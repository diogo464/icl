options {
	STATIC = false;
	LOOKAHEAD = 2;
}

PARSER_BEGIN(CalcParser)
package icl.parser;
import icl.hir.*;
import icl.ast.*;

import java.util.ArrayList;

public class CalcParser {

}

PARSER_END(CalcParser)

SKIP :
{
	" " | "\t" | "\r" | "\n"
}

TOKEN :
{
	< KW_LET	: "let"												> |
	< KW_IF		: "if"												> |
	< KW_ELSE	: "else"											> |
	< KW_WHILE	: "while"											> |
	< KW_MUT	: "mut"												> |
	< KW_TRUE	: "true"											> |
	< KW_FALSE	: "false"											> |
	< KW_FN		: "fn"												> |
	< KW_STRUCT	: "struct"											> |
	< KW_PRINT	: "print"											> |
	< KW_PRINTLN: "println"											> |
	< IDENT		: (["a"-"z", "A"-"Z"](["a"-"z","A"-"Z","0"-"9"])*)	> |
	< NUM		: ((["0"-"9"])+)									> |
	< STRLIT	: "\"" (("\\" ("\\" | "n" | "r" | "\"")) | (~["\\", "\"", "\n", "\r"]))* "\"" > |
	< COMMA		: "," 												> |
	< PLUS		: "+" 												> |
	< MINUS		: "-" 												> |
	< MUL		: "*" 												> |
	< DIV		: "/" 												> |
	< LPAREN	: "("												> |
	< RPAREN	: ")"												> |
	< LBRACK	: "{"												> |
	< RBRACK	: "}"												> |
	< SEMICOL	: ";"												> |
	< EQ		: "="												> |
	< CMP		: "=="												> |
	< GT		: ">"												> |
	< GTE		: ">="												> |
	< LT		: "<"												> |
	< LTE		: "<="												> |
	< LAND		: "&&"												> |
	< LOR		: "||"												> |
	< LNOT		: "~"												> |
	< DEREF		: "!"												> |
	< ASSIGN	: ":="												>
}

AstNode<Hir> Start():
{ var t = (AstNode<Hir>) null; }
{
	t = Expr() <SEMICOL> <SEMICOL>
	{ return t; }
}

AstNode<Hir> Stmt():
{ AstNode<Hir> n; }
{
	(n = StmtAssign() | n = StmtDecl() | n = StmtWhile() | n = StmtPrint())
	{ return n; }
}

AstNode<Hir> Expr():
{ AstNode<Hir> n; }
{
	(n = ExprBlock() | n = ExprLOr() | n = ExprIf())
	{ return n; }
}

AstNode<Hir> StmtAssign():
{
	Token name = null;	
	AstNode<Hir> exp = null;
}
{
	(name = <IDENT>) <ASSIGN> (exp = Expr()) <SEMICOL>
	{ return Parser.astAssign(name, exp); }
}

AstNode<Hir> StmtDecl():
{
	Token mut = null;
	Token ident = null;
	AstNode<Hir> exp = null;
}
{
	<KW_LET> (mut = <KW_MUT>)? (ident = <IDENT>) <EQ> (exp = Expr()) <SEMICOL>
	{ return Parser.astDecl(ident, exp, mut != null); }
}

AstNode<Hir> StmtWhile():
{
	var condition = (AstNode<Hir>) null;
	var body = (AstNode<Hir>) null;
}
{
	<KW_WHILE> 	(condition = Expr()) (body = ExprBlock())? <SEMICOL>
	{ if (body == null) { body = Parser.astEmptyNode(); } }
	{ return Parser.astLoop(condition, body); }
}

AstNode<Hir> StmtPrint():
{
	var n = (Token) null;
	var expr = (AstNode<Hir>) null;
}
{
	(n = <KW_PRINT> | n = <KW_PRINTLN>) (expr = Expr())? <SEMICOL>
	{ if (expr == null) { expr = Parser.astEmptyNode(); } }
	{ return Parser.astPrint(n, expr); }
}

AstNode<Hir> ExprIf():
{
	var conditionals 	= new ArrayList<AstIf.Conditional<Hir>>();
	var fallthrough 	= (AstNode<Hir>) null;
	var condition		= (AstNode<Hir>) null;
	var expression 		= (AstNode<Hir>) null;
}
{
	<KW_IF> (condition = Expr()) (expression = ExprBlock())
	{ conditionals.add(Parser.astIfConditional(condition, expression)); }
	(<KW_ELSE> <KW_IF> (condition = Expr()) (expression = ExprBlock()) {conditionals.add(Parser.astIfConditional(condition, expression));})*
	(<KW_ELSE> expression = ExprBlock())?
	{ if( expression == null) { fallthrough = Parser.astEmptyNode(); } else { fallthrough = expression; } }
	{ return Parser.astIf(conditionals, fallthrough); }
}

AstNode<Hir> ExprBlock():
{ 
	AstNode<Hir> stmt = null;
	AstNode<Hir> body = null;
	ArrayList<AstNode<Hir>> stmts = new ArrayList<>();
}
{
	( 
		<LBRACK> 
			(stmt = Stmt() { stmts.add(stmt); })*
			(body = Expr())?
		<RBRACK>
	)
	{ 
		if( body == null )
			body = Parser.astEmptyNode();
		return Parser.astScope(stmts, body);
	}
}

AstNode<Hir> ExprLOr():
{
	Token op = null;
	AstNode<Hir> l = null, r= null;
}
{
	l = ExprLAnd() ( 
		(op = <LOR>) r = ExprLAnd()
		{ 
			if( op != null ) {
				l = Parser.astBinOp(AstBinOp.Kind.LOR, l, r);
			}
		}
	)*
	{ return l; }	
}

AstNode<Hir> ExprLAnd():
{
	Token op = null;
	AstNode<Hir> l = null, r= null;
}
{
	l = ExprCmp() ( 
		(op = <LAND>) r = ExprCmp()
		{ 
			if( op != null ) {
				l = Parser.astBinOp(AstBinOp.Kind.LAND, l, r);
			}
		}
	)*
	{ return l; }
}

AstNode<Hir> ExprCmp():
{
	Token op = null;
	AstNode<Hir> l = null, r= null;
}
{
	l = ExprRel() ( 
		(op = <CMP>) r = ExprRel()
		{ 
			if( op != null ) {
				l = Parser.astBinOp(AstBinOp.Kind.CMP, l, r);
			}
		}
	)*
	{ return l; }
}

AstNode<Hir> ExprRel():
{
	Token op = null;
	AstNode<Hir> l = null, r= null;
}
{
	l = ExprAddSub() ( 
		(op = <GT> | op = <GTE> | op = <LT> | op = <LTE>) r = ExprAddSub()
		{ 
			if( op != null ) {
				if( op.kind == GT ) { l = Parser.astBinOp(AstBinOp.Kind.GT, l, r);}
				else if( op.kind == GTE ) { l = Parser.astBinOp(AstBinOp.Kind.GTE, l, r); }
				else if( op.kind == LT ) { l = Parser.astBinOp(AstBinOp.Kind.LT, l, r); }
				else if( op.kind == LTE ) { l = Parser.astBinOp(AstBinOp.Kind.LTE, l, r); }
			}
		}
	)*
	{ return l; }
}

AstNode<Hir> ExprAddSub():
{ 
	Token op = null;
	AstNode<Hir> l = null, r = null;
}
{
	l = ExprMulDiv() ( 
		(op = <PLUS> | op = <MINUS>) r = ExprMulDiv()
		{ 
			if( op != null ) {
				if( op.kind == PLUS ) { l = Parser.astBinOp(AstBinOp.Kind.ADD, l, r); }
				else { l = Parser.astBinOp(AstBinOp.Kind.SUB, l, r); }
			}
		}
	)*
	{ return l; }	
}

AstNode<Hir> ExprMulDiv():
{
	Token op = null;
	AstNode<Hir> l = null, r = null;
}
{
	l = ExprUnary() ( 
		(op = <MUL> | op = <DIV>) r = ExprUnary()
		{
				if( op.kind == MUL ) { l = Parser.astBinOp(AstBinOp.Kind.MUL, l, r); }
				else { l = Parser.astBinOp(AstBinOp.Kind.DIV, l, r); }
		}
	)*
	{ return l; }
}

AstNode<Hir> ExprUnary():
{ 
	Token n = null;
	ArrayList<AstUnaryOp.Kind> k = null;
	AstNode<Hir> t = null;
}
{
	( 
		(
			n = <PLUS> | n = <MINUS> | n = <LNOT> | n = <DEREF>
			{ 
			if ( k == null ) { k = new ArrayList<>(); }
			if ( n.kind == PLUS ) { k.add(AstUnaryOp.Kind.POS); }
			else if ( n.kind == MINUS ) { k.add(AstUnaryOp.Kind.NEG); }
			else if ( n.kind == LNOT ) { k.add(AstUnaryOp.Kind.LNOT); }
			else if ( n.kind == DEREF ) { k.add(AstUnaryOp.Kind.DEREF); }
			}
		)* 
		t = ExprLitParenCall() 
	)
	{
		if( k == null ) {
			return t;
		}else {
			AstNode<Hir> tmp = t;
			for( var kind : k )
				tmp = Parser.astUnaryOp(kind, tmp);
			return tmp;
		}
	}
}

AstNode<Hir> ExprLitParenCall():
{
	var n 			= (Token) null;
	var t 			= (AstNode<Hir>) null;
	var arguments 	= new ArrayList<AstNode<Hir>>();
	var argument 	= (AstNode<Hir>) null;
}
{
	( 
		n = <NUM> { return Parser.astNum(n); } 		|
		n = <KW_TRUE> { return Parser.astBool(n); }	|
		n = <KW_FALSE> { return Parser.astBool(n); }|
		n = <IDENT> { return Parser.astVar(n); }	|
		n = <STRLIT> { return Parser.astStr(n); } 	|
		<LPAREN> t = Expr() <RPAREN>
		(<LPAREN>
			(argument = Expr() {arguments.add(argument);})
			(<COMMA> argument = Expr() {arguments.add(argument);})*
		<RPAREN> {return Parser.astCall(t, arguments); })?
		{ return t; }
	)
}
