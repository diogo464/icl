options {
	STATIC = false;
}

PARSER_BEGIN(CalcParser)
package icl.ast;

import java.util.ArrayList;

public class CalcParser {

}

PARSER_END(CalcParser)

SKIP :
{
	" " | "\t" | "\r"
}

TOKEN :
{
	< KW_DEF: "def"												> |
	< KW_IN	: "in"												> |
	< KW_END: "end"												> |
	< IDENT	: (["a"-"z", "A"-"Z"](["a"-"z","A"-"Z","0"-"9"])*)	> |
	< NUM	: ((["0"-"9"])+)									> |
	< PLUS	: "+" 												> |
	< MINUS	: "-" 												> |
	< MUL	: "*" 												> |
	< DIV	: "/" 												> |
	< LPAREN: "("												> |
	< RPAREN: ")"												> |
	< EQ	: "="												> |
	< NL	: "\n"												>
}

AstNode Start():
{ AstNode t; }
{
	t = Exp() (<NL>)*
	{ return t; }
}

AstNode Exp():
{ AstNode n; }
{
	(n = Def() | n = ExpAddSub())
	{ return n; }
}

AstNode Def():
{ 
	AstDecl decl = null;
	ArrayList<AstDecl> decls = new ArrayList<>();
	AstNode body = null;
}
{
	( 
		<KW_DEF> 
			(<NL>)* ( decl = Decl() (<NL>)* { decls.add(decl); })* 
		<KW_IN> (<NL>)*
			(body = Exp())? (<NL>)*
		<KW_END> 
	)
	{ 
		if( body == null )
			body = new AstEmptyNode();
		return new AstDef(decls, body);
	}
}

AstDecl Decl():
{ Token ident; AstNode exp; }
{
	( ident = <IDENT> <EQ> exp = Exp() )
	{ return new AstDecl(ident, exp); }
}

AstNode ExpAddSub():
{ 
	Token op = null;
	AstNode l = null, r = null;
}
{
	l = ExpMulDiv() ( 
		(op = <PLUS> | op = <MINUS>) r = ExpMulDiv()
		{ 
			if( op != null ) {
				if( op.kind == PLUS ) { l = new AstBinOp(AstBinOp.Kind.ADD, l, r); }
				else { l = new AstBinOp(AstBinOp.Kind.SUB, l, r); }
			}
		}
	)*
	{ return l; }	
}

AstNode ExpMulDiv():
{
	Token op = null;
	AstNode l = null, r = null;
}
{
	l = ExpUnary() ( 
		(op = <MUL> | op = <DIV>) r = ExpUnary()
		{
				if( op.kind == MUL ) { l = new AstBinOp(AstBinOp.Kind.MUL, l, r); }
				else { l = new AstBinOp(AstBinOp.Kind.DIV, l, r); }
		}
	)*
	{ return l; }
}

AstNode ExpUnary():
{ 
	Token n = null;
	ArrayList<AstUnaryOp.Kind> k = null;
	AstNode t = null;
}
{
	( 
		(
			n = <PLUS> | n = <MINUS>
			{ 
			if ( k == null ) { k = new ArrayList<>(); }
			if ( n.kind == PLUS ) { k.add(AstUnaryOp.Kind.POS); }
			else if ( n.kind == MINUS ) { k.add(AstUnaryOp.Kind.NEG); }
			}
		)* 
		t = ExpLitParen() 
	)
	{
		if( k == null ) {
			return t;
		}else {
			AstNode tmp = t;
			for( var kind : k )
				tmp = new AstUnaryOp(kind, tmp);
			return tmp;
		}
	}
}

AstNode ExpLitParen():
{ Token n = null; AstNode t = null; }
{
	( 
		n = <NUM> { t = new AstNum(n); } 	|
		n = <IDENT> { t = new AstVar(n); }	|
		<LPAREN> t = Exp() <RPAREN>
	)
	{ return t; }
}
